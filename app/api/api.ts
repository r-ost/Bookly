/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "//localhost:6200/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddBookingDto
 */
export interface AddBookingDto {
    /**
     * 
     * @type {string}
     * @memberof AddBookingDto
     */
    itemId?: string;
    /**
     * 
     * @type {string}
     * @memberof AddBookingDto
     */
    itemType?: string;
    /**
     * 
     * @type {Date}
     * @memberof AddBookingDto
     */
    startDateTime?: Date;
}
/**
 * 
 * @export
 * @interface BaseBooking
 */
export interface BaseBooking {
    /**
     * 
     * @type {boolean}
     * @memberof BaseBooking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BaseBooking
     */
    bookingId?: number;
    /**
     * 
     * @type {ItemBase}
     * @memberof BaseBooking
     */
    item?: ItemBase;
    /**
     * 
     * @type {Date}
     * @memberof BaseBooking
     */
    startDate?: Date;
}
/**
 * 
 * @export
 * @interface Booking
 */
export interface Booking {
    /**
     * 
     * @type {boolean}
     * @memberof Booking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Booking
     */
    externalBookingId?: number;
    /**
     * 
     * @type {number}
     * @memberof Booking
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    itemId?: string;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    itemType?: Booking.ItemTypeEnum;
    /**
     * 
     * @type {Date}
     * @memberof Booking
     */
    startDateTime?: Date;
    /**
     * 
     * @type {User}
     * @memberof Booking
     */
    user?: User;
}

/**
 * @export
 * @namespace Booking
 */
export namespace Booking {
    /**
     * @export
     * @enum {string}
     */
    export enum ItemTypeEnum {
        CAR = <any> 'CAR',
        PARKING = <any> 'PARKING',
        ROOM = <any> 'ROOM'
    }
}
/**
 * 
 * @export
 * @interface CarItem
 */
export interface CarItem {
    /**
     * 
     * @type {boolean}
     * @memberof CarItem
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CarItem
     */
    brand?: string;
    /**
     * 
     * @type {Date}
     * @memberof CarItem
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof CarItem
     */
    engine?: string;
    /**
     * 
     * @type {string}
     * @memberof CarItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CarItem
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof CarItem
     */
    model?: string;
    /**
     * 
     * @type {number}
     * @memberof CarItem
     */
    price?: number;
    /**
     * 
     * @type {Date}
     * @memberof CarItem
     */
    startDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof CarItem
     */
    year?: number;
}
/**
 * 
 * @export
 * @interface CarItemsResponse
 */
export interface CarItemsResponse {
    /**
     * 
     * @type {Array<CarItem>}
     * @memberof CarItemsResponse
     */
    items?: Array<CarItem>;
    /**
     * 
     * @type {number}
     * @memberof CarItemsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof CarItemsResponse
     */
    totalItems?: number;
    /**
     * 
     * @type {number}
     * @memberof CarItemsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface CarlyBooking
 */
export interface CarlyBooking {
    /**
     * 
     * @type {boolean}
     * @memberof CarlyBooking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CarlyBooking
     */
    bookingId?: number;
    /**
     * 
     * @type {CarItem}
     * @memberof CarlyBooking
     */
    item?: CarItem;
    /**
     * 
     * @type {Date}
     * @memberof CarlyBooking
     */
    startDate?: Date;
}
/**
 * 
 * @export
 * @interface CarlyBookingsResponse
 */
export interface CarlyBookingsResponse {
    /**
     * 
     * @type {Array<CarlyBooking>}
     * @memberof CarlyBookingsResponse
     */
    items?: Array<CarlyBooking>;
    /**
     * 
     * @type {number}
     * @memberof CarlyBookingsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof CarlyBookingsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface CarlyUserBooking
 */
export interface CarlyUserBooking {
    /**
     * 
     * @type {boolean}
     * @memberof CarlyUserBooking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CarlyUserBooking
     */
    bookingId?: number;
    /**
     * 
     * @type {CarItem}
     * @memberof CarlyUserBooking
     */
    item?: CarItem;
    /**
     * 
     * @type {Date}
     * @memberof CarlyUserBooking
     */
    startDate?: Date;
    /**
     * 
     * @type {User}
     * @memberof CarlyUserBooking
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface CarlyUserBookingsResponse
 */
export interface CarlyUserBookingsResponse {
    /**
     * 
     * @type {Array<CarlyUserBooking>}
     * @memberof CarlyUserBookingsResponse
     */
    items?: Array<CarlyUserBooking>;
    /**
     * 
     * @type {number}
     * @memberof CarlyUserBookingsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof CarlyUserBookingsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface FlatAddress
 */
export interface FlatAddress {
    /**
     * 
     * @type {string}
     * @memberof FlatAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof FlatAddress
     */
    houseNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof FlatAddress
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FlatAddress
     */
    localNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof FlatAddress
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof FlatAddress
     */
    streetName?: string;
}
/**
 * 
 * @export
 * @interface FlatFacility
 */
export interface FlatFacility {
    /**
     * 
     * @type {number}
     * @memberof FlatFacility
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FlatFacility
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface FlatImage
 */
export interface FlatImage {
    /**
     * 
     * @type {number}
     * @memberof FlatImage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FlatImage
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface FlatItem
 */
export interface FlatItem {
    /**
     * 
     * @type {boolean}
     * @memberof FlatItem
     */
    active?: boolean;
    /**
     * 
     * @type {FlatAddress}
     * @memberof FlatItem
     */
    address?: FlatAddress;
    /**
     * 
     * @type {number}
     * @memberof FlatItem
     */
    area?: number;
    /**
     * 
     * @type {string}
     * @memberof FlatItem
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof FlatItem
     */
    endDateTime?: Date;
    /**
     * 
     * @type {Array<FlatFacility>}
     * @memberof FlatItem
     */
    facilities?: Array<FlatFacility>;
    /**
     * 
     * @type {string}
     * @memberof FlatItem
     */
    id?: string;
    /**
     * 
     * @type {Array<FlatImage>}
     * @memberof FlatItem
     */
    images?: Array<FlatImage>;
    /**
     * 
     * @type {string}
     * @memberof FlatItem
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FlatItem
     */
    numberOfGuests?: number;
    /**
     * 
     * @type {number}
     * @memberof FlatItem
     */
    rooms?: number;
    /**
     * 
     * @type {Date}
     * @memberof FlatItem
     */
    startDateTime?: Date;
}
/**
 * 
 * @export
 * @interface FlatItemsResponse
 */
export interface FlatItemsResponse {
    /**
     * 
     * @type {Array<FlatItem>}
     * @memberof FlatItemsResponse
     */
    items?: Array<FlatItem>;
    /**
     * 
     * @type {number}
     * @memberof FlatItemsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof FlatItemsResponse
     */
    totalItems?: number;
    /**
     * 
     * @type {number}
     * @memberof FlatItemsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface FlatlyBooking
 */
export interface FlatlyBooking {
    /**
     * 
     * @type {boolean}
     * @memberof FlatlyBooking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FlatlyBooking
     */
    bookingId?: number;
    /**
     * 
     * @type {FlatItem}
     * @memberof FlatlyBooking
     */
    item?: FlatItem;
    /**
     * 
     * @type {Date}
     * @memberof FlatlyBooking
     */
    startDate?: Date;
}
/**
 * 
 * @export
 * @interface FlatlyBookingsResponse
 */
export interface FlatlyBookingsResponse {
    /**
     * 
     * @type {Array<FlatlyBooking>}
     * @memberof FlatlyBookingsResponse
     */
    items?: Array<FlatlyBooking>;
    /**
     * 
     * @type {number}
     * @memberof FlatlyBookingsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof FlatlyBookingsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface FlatlyUserBooking
 */
export interface FlatlyUserBooking {
    /**
     * 
     * @type {boolean}
     * @memberof FlatlyUserBooking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FlatlyUserBooking
     */
    bookingId?: number;
    /**
     * 
     * @type {FlatItem}
     * @memberof FlatlyUserBooking
     */
    item?: FlatItem;
    /**
     * 
     * @type {Date}
     * @memberof FlatlyUserBooking
     */
    startDate?: Date;
    /**
     * 
     * @type {User}
     * @memberof FlatlyUserBooking
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface FlatlyUserBookingsResponse
 */
export interface FlatlyUserBookingsResponse {
    /**
     * 
     * @type {Array<FlatlyUserBooking>}
     * @memberof FlatlyUserBookingsResponse
     */
    items?: Array<FlatlyUserBooking>;
    /**
     * 
     * @type {number}
     * @memberof FlatlyUserBookingsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof FlatlyUserBookingsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface ItemBase
 */
export interface ItemBase {
    /**
     * 
     * @type {boolean}
     * @memberof ItemBase
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemBase
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface JwtRequest
 */
export interface JwtRequest {
    /**
     * 
     * @type {string}
     * @memberof JwtRequest
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof JwtRequest
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    templated?: boolean;
}
/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelAndView
     */
    model?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndView.StatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
 * @export
 * @namespace ModelAndView
 */
export namespace ModelAndView {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACCEPTED = <any> 'ACCEPTED',
        ALREADYREPORTED = <any> 'ALREADY_REPORTED',
        BADGATEWAY = <any> 'BAD_GATEWAY',
        BADREQUEST = <any> 'BAD_REQUEST',
        BANDWIDTHLIMITEXCEEDED = <any> 'BANDWIDTH_LIMIT_EXCEEDED',
        CHECKPOINT = <any> 'CHECKPOINT',
        CONFLICT = <any> 'CONFLICT',
        CONTINUE = <any> 'CONTINUE',
        CREATED = <any> 'CREATED',
        DESTINATIONLOCKED = <any> 'DESTINATION_LOCKED',
        EXPECTATIONFAILED = <any> 'EXPECTATION_FAILED',
        FAILEDDEPENDENCY = <any> 'FAILED_DEPENDENCY',
        FORBIDDEN = <any> 'FORBIDDEN',
        FOUND = <any> 'FOUND',
        GATEWAYTIMEOUT = <any> 'GATEWAY_TIMEOUT',
        GONE = <any> 'GONE',
        HTTPVERSIONNOTSUPPORTED = <any> 'HTTP_VERSION_NOT_SUPPORTED',
        IMUSED = <any> 'IM_USED',
        INSUFFICIENTSPACEONRESOURCE = <any> 'INSUFFICIENT_SPACE_ON_RESOURCE',
        INSUFFICIENTSTORAGE = <any> 'INSUFFICIENT_STORAGE',
        INTERNALSERVERERROR = <any> 'INTERNAL_SERVER_ERROR',
        IAMATEAPOT = <any> 'I_AM_A_TEAPOT',
        LENGTHREQUIRED = <any> 'LENGTH_REQUIRED',
        LOCKED = <any> 'LOCKED',
        LOOPDETECTED = <any> 'LOOP_DETECTED',
        METHODFAILURE = <any> 'METHOD_FAILURE',
        METHODNOTALLOWED = <any> 'METHOD_NOT_ALLOWED',
        MOVEDPERMANENTLY = <any> 'MOVED_PERMANENTLY',
        MOVEDTEMPORARILY = <any> 'MOVED_TEMPORARILY',
        MULTIPLECHOICES = <any> 'MULTIPLE_CHOICES',
        MULTISTATUS = <any> 'MULTI_STATUS',
        NETWORKAUTHENTICATIONREQUIRED = <any> 'NETWORK_AUTHENTICATION_REQUIRED',
        NONAUTHORITATIVEINFORMATION = <any> 'NON_AUTHORITATIVE_INFORMATION',
        NOTACCEPTABLE = <any> 'NOT_ACCEPTABLE',
        NOTEXTENDED = <any> 'NOT_EXTENDED',
        NOTFOUND = <any> 'NOT_FOUND',
        NOTIMPLEMENTED = <any> 'NOT_IMPLEMENTED',
        NOTMODIFIED = <any> 'NOT_MODIFIED',
        NOCONTENT = <any> 'NO_CONTENT',
        OK = <any> 'OK',
        PARTIALCONTENT = <any> 'PARTIAL_CONTENT',
        PAYLOADTOOLARGE = <any> 'PAYLOAD_TOO_LARGE',
        PAYMENTREQUIRED = <any> 'PAYMENT_REQUIRED',
        PERMANENTREDIRECT = <any> 'PERMANENT_REDIRECT',
        PRECONDITIONFAILED = <any> 'PRECONDITION_FAILED',
        PRECONDITIONREQUIRED = <any> 'PRECONDITION_REQUIRED',
        PROCESSING = <any> 'PROCESSING',
        PROXYAUTHENTICATIONREQUIRED = <any> 'PROXY_AUTHENTICATION_REQUIRED',
        REQUESTEDRANGENOTSATISFIABLE = <any> 'REQUESTED_RANGE_NOT_SATISFIABLE',
        REQUESTENTITYTOOLARGE = <any> 'REQUEST_ENTITY_TOO_LARGE',
        REQUESTHEADERFIELDSTOOLARGE = <any> 'REQUEST_HEADER_FIELDS_TOO_LARGE',
        REQUESTTIMEOUT = <any> 'REQUEST_TIMEOUT',
        REQUESTURITOOLONG = <any> 'REQUEST_URI_TOO_LONG',
        RESETCONTENT = <any> 'RESET_CONTENT',
        SEEOTHER = <any> 'SEE_OTHER',
        SERVICEUNAVAILABLE = <any> 'SERVICE_UNAVAILABLE',
        SWITCHINGPROTOCOLS = <any> 'SWITCHING_PROTOCOLS',
        TEMPORARYREDIRECT = <any> 'TEMPORARY_REDIRECT',
        TOOEARLY = <any> 'TOO_EARLY',
        TOOMANYREQUESTS = <any> 'TOO_MANY_REQUESTS',
        UNAUTHORIZED = <any> 'UNAUTHORIZED',
        UNAVAILABLEFORLEGALREASONS = <any> 'UNAVAILABLE_FOR_LEGAL_REASONS',
        UNPROCESSABLEENTITY = <any> 'UNPROCESSABLE_ENTITY',
        UNSUPPORTEDMEDIATYPE = <any> 'UNSUPPORTED_MEDIA_TYPE',
        UPGRADEREQUIRED = <any> 'UPGRADE_REQUIRED',
        URITOOLONG = <any> 'URI_TOO_LONG',
        USEPROXY = <any> 'USE_PROXY',
        VARIANTALSONEGOTIATES = <any> 'VARIANT_ALSO_NEGOTIATES'
    }
}
/**
 * 
 * @export
 * @interface ParkingItem
 */
export interface ParkingItem {
    /**
     * 
     * @type {boolean}
     * @memberof ParkingItem
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ParkingItem
     */
    booked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParkingItem
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingItem
     */
    imageLink?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingItem
     */
    parkingName?: string;
    /**
     * 
     * @type {number}
     * @memberof ParkingItem
     */
    pricePerHour?: number;
    /**
     * 
     * @type {number}
     * @memberof ParkingItem
     */
    spotNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof ParkingItem
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingItem
     */
    streetTag?: string;
}
/**
 * 
 * @export
 * @interface ParkingItemsResponse
 */
export interface ParkingItemsResponse {
    /**
     * 
     * @type {Array<ParkingItem>}
     * @memberof ParkingItemsResponse
     */
    items?: Array<ParkingItem>;
    /**
     * 
     * @type {number}
     * @memberof ParkingItemsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof ParkingItemsResponse
     */
    totalItems?: number;
    /**
     * 
     * @type {number}
     * @memberof ParkingItemsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface ParklyBooking
 */
export interface ParklyBooking {
    /**
     * 
     * @type {boolean}
     * @memberof ParklyBooking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ParklyBooking
     */
    bookingId?: number;
    /**
     * 
     * @type {ParkingItem}
     * @memberof ParklyBooking
     */
    item?: ParkingItem;
    /**
     * 
     * @type {Date}
     * @memberof ParklyBooking
     */
    startDate?: Date;
}
/**
 * 
 * @export
 * @interface ParklyBookingsResponse
 */
export interface ParklyBookingsResponse {
    /**
     * 
     * @type {Array<ParklyBooking>}
     * @memberof ParklyBookingsResponse
     */
    items?: Array<ParklyBooking>;
    /**
     * 
     * @type {number}
     * @memberof ParklyBookingsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof ParklyBookingsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface ParklyUserBooking
 */
export interface ParklyUserBooking {
    /**
     * 
     * @type {boolean}
     * @memberof ParklyUserBooking
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ParklyUserBooking
     */
    bookingId?: number;
    /**
     * 
     * @type {ParkingItem}
     * @memberof ParklyUserBooking
     */
    item?: ParkingItem;
    /**
     * 
     * @type {Date}
     * @memberof ParklyUserBooking
     */
    startDate?: Date;
    /**
     * 
     * @type {User}
     * @memberof ParklyUserBooking
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface ParklyUserBookingsResponse
 */
export interface ParklyUserBookingsResponse {
    /**
     * 
     * @type {Array<ParklyUserBooking>}
     * @memberof ParklyUserBookingsResponse
     */
    items?: Array<ParklyUserBooking>;
    /**
     * 
     * @type {number}
     * @memberof ParklyUserBookingsResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof ParklyUserBookingsResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface UpdateBookingDto
 */
export interface UpdateBookingDto {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateBookingDto
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookingDto
     */
    itemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookingDto
     */
    itemType?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdateBookingDto
     */
    startDateTime?: Date;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    admin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {number}
     * @memberof UsersResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersResponse
     */
    totalPages?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersResponse
     */
    users?: Array<User>;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}
/**
 * BasicErrorControllerApi - fetch parameter creator
 * @export
 */
export const BasicErrorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingHEAD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingOPTIONS(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPATCH(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingDELETE(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingHEAD(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingOPTIONS(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPATCH(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options)(this.fetch, this.basePath);
    }

}
/**
 * BookingsControllerApi - fetch parameter creator
 * @export
 */
export const BookingsControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addBooking
         * @param {AddBookingDto} body addBookingDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBookingUsingPOST(body: AddBookingDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addBookingUsingPOST.');
            }
            const localVarPath = `/bookings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddBookingDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteBooking
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookingUsingDELETE(bookingId: number, options: any = {}): FetchArgs {
            // verify required parameter 'bookingId' is not null or undefined
            if (bookingId === null || bookingId === undefined) {
                throw new RequiredError('bookingId','Required parameter bookingId was null or undefined when calling deleteBookingUsingDELETE.');
            }
            const localVarPath = `/bookings/{bookingId}`
                .replace(`{${"bookingId"}}`, encodeURIComponent(String(bookingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBooking
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookingUsingGET(bookingId: number, options: any = {}): FetchArgs {
            // verify required parameter 'bookingId' is not null or undefined
            if (bookingId === null || bookingId === undefined) {
                throw new RequiredError('bookingId','Required parameter bookingId was null or undefined when calling getBookingUsingGET.');
            }
            const localVarPath = `/bookings/{bookingId}`
                .replace(`{${"bookingId"}}`, encodeURIComponent(String(bookingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCarsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCarsBookingsUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getCarsBookingsUsingGET.');
            }
            const localVarPath = `/bookings/all/cars`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFlatsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlatsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getFlatsBookingsUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getFlatsBookingsUsingGET.');
            }
            const localVarPath = `/bookings/all/flats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getParkingsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkingsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getParkingsBookingsUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getParkingsBookingsUsingGET.');
            }
            const localVarPath = `/bookings/all/parkings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserCars
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCarsUsingGET(page: number, size: number, filter?: string, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserCarsUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getUserCarsUsingGET.');
            }
            const localVarPath = `/bookings/user/cars`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserFlats
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlatsUsingGET(page: number, size: number, filter?: string, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserFlatsUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getUserFlatsUsingGET.');
            }
            const localVarPath = `/bookings/user/flats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserParkings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserParkingsUsingGET(page: number, size: number, filter?: string, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserParkingsUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getUserParkingsUsingGET.');
            }
            const localVarPath = `/bookings/user/parkings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateBooking
         * @param {UpdateBookingDto} body updateBookingDto
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookingUsingPUT(body: UpdateBookingDto, bookingId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateBookingUsingPUT.');
            }
            // verify required parameter 'bookingId' is not null or undefined
            if (bookingId === null || bookingId === undefined) {
                throw new RequiredError('bookingId','Required parameter bookingId was null or undefined when calling updateBookingUsingPUT.');
            }
            const localVarPath = `/bookings/{bookingId}`
                .replace(`{${"bookingId"}}`, encodeURIComponent(String(bookingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateBookingDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookingsControllerApi - functional programming interface
 * @export
 */
export const BookingsControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addBooking
         * @param {AddBookingDto} body addBookingDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBookingUsingPOST(body: AddBookingDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Booking> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).addBookingUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteBooking
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookingUsingDELETE(bookingId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).deleteBookingUsingDELETE(bookingId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBooking
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookingUsingGET(bookingId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseBooking> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).getBookingUsingGET(bookingId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCarsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CarlyUserBookingsResponse> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).getCarsBookingsUsingGET(page, size, filter, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getFlatsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlatsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FlatlyUserBookingsResponse> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).getFlatsBookingsUsingGET(page, size, filter, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getParkingsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkingsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParklyUserBookingsResponse> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).getParkingsBookingsUsingGET(page, size, filter, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserCars
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCarsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CarlyBookingsResponse> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).getUserCarsUsingGET(page, size, filter, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserFlats
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlatsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FlatlyBookingsResponse> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).getUserFlatsUsingGET(page, size, filter, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserParkings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserParkingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParklyBookingsResponse> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).getUserParkingsUsingGET(page, size, filter, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateBooking
         * @param {UpdateBookingDto} body updateBookingDto
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookingUsingPUT(body: UpdateBookingDto, bookingId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Booking> {
            const localVarFetchArgs = BookingsControllerApiFetchParamCreator(configuration).updateBookingUsingPUT(body, bookingId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BookingsControllerApi - factory interface
 * @export
 */
export const BookingsControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addBooking
         * @param {AddBookingDto} body addBookingDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBookingUsingPOST(body: AddBookingDto, options?: any) {
            return BookingsControllerApiFp(configuration).addBookingUsingPOST(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteBooking
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookingUsingDELETE(bookingId: number, options?: any) {
            return BookingsControllerApiFp(configuration).deleteBookingUsingDELETE(bookingId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBooking
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookingUsingGET(bookingId: number, options?: any) {
            return BookingsControllerApiFp(configuration).getBookingUsingGET(bookingId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCarsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
            return BookingsControllerApiFp(configuration).getCarsBookingsUsingGET(page, size, filter, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getFlatsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlatsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
            return BookingsControllerApiFp(configuration).getFlatsBookingsUsingGET(page, size, filter, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getParkingsBookings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkingsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
            return BookingsControllerApiFp(configuration).getParkingsBookingsUsingGET(page, size, filter, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserCars
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCarsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
            return BookingsControllerApiFp(configuration).getUserCarsUsingGET(page, size, filter, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserFlats
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlatsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
            return BookingsControllerApiFp(configuration).getUserFlatsUsingGET(page, size, filter, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserParkings
         * @param {number} page page
         * @param {number} size size
         * @param {string} [filter] filter
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserParkingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
            return BookingsControllerApiFp(configuration).getUserParkingsUsingGET(page, size, filter, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateBooking
         * @param {UpdateBookingDto} body updateBookingDto
         * @param {number} bookingId bookingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookingUsingPUT(body: UpdateBookingDto, bookingId: number, options?: any) {
            return BookingsControllerApiFp(configuration).updateBookingUsingPUT(body, bookingId, options)(fetch, basePath);
        },
    };
};

/**
 * BookingsControllerApi - object-oriented interface
 * @export
 * @class BookingsControllerApi
 * @extends {BaseAPI}
 */
export class BookingsControllerApi extends BaseAPI {
    /**
     * 
     * @summary addBooking
     * @param {AddBookingDto} body addBookingDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public addBookingUsingPOST(body: AddBookingDto, options?: any) {
        return BookingsControllerApiFp(this.configuration).addBookingUsingPOST(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteBooking
     * @param {number} bookingId bookingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public deleteBookingUsingDELETE(bookingId: number, options?: any) {
        return BookingsControllerApiFp(this.configuration).deleteBookingUsingDELETE(bookingId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBooking
     * @param {number} bookingId bookingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public getBookingUsingGET(bookingId: number, options?: any) {
        return BookingsControllerApiFp(this.configuration).getBookingUsingGET(bookingId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCarsBookings
     * @param {number} page page
     * @param {number} size size
     * @param {string} [filter] filter
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public getCarsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
        return BookingsControllerApiFp(this.configuration).getCarsBookingsUsingGET(page, size, filter, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getFlatsBookings
     * @param {number} page page
     * @param {number} size size
     * @param {string} [filter] filter
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public getFlatsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
        return BookingsControllerApiFp(this.configuration).getFlatsBookingsUsingGET(page, size, filter, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getParkingsBookings
     * @param {number} page page
     * @param {number} size size
     * @param {string} [filter] filter
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public getParkingsBookingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
        return BookingsControllerApiFp(this.configuration).getParkingsBookingsUsingGET(page, size, filter, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserCars
     * @param {number} page page
     * @param {number} size size
     * @param {string} [filter] filter
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public getUserCarsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
        return BookingsControllerApiFp(this.configuration).getUserCarsUsingGET(page, size, filter, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserFlats
     * @param {number} page page
     * @param {number} size size
     * @param {string} [filter] filter
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public getUserFlatsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
        return BookingsControllerApiFp(this.configuration).getUserFlatsUsingGET(page, size, filter, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserParkings
     * @param {number} page page
     * @param {number} size size
     * @param {string} [filter] filter
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public getUserParkingsUsingGET(page: number, size: number, filter?: string, sort?: string, options?: any) {
        return BookingsControllerApiFp(this.configuration).getUserParkingsUsingGET(page, size, filter, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateBooking
     * @param {UpdateBookingDto} body updateBookingDto
     * @param {number} bookingId bookingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingsControllerApi
     */
    public updateBookingUsingPUT(body: UpdateBookingDto, bookingId: number, options?: any) {
        return BookingsControllerApiFp(this.configuration).updateBookingUsingPUT(body, bookingId, options)(this.fetch, this.basePath);
    }

}
/**
 * ItemsControllerApi - fetch parameter creator
 * @export
 */
export const ItemsControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCarItems
         * @param {number} page page
         * @param {number} pageSize pageSize
         * @param {string} [dateSort] dateSort
         * @param {string} [location] location
         * @param {string} [model] model
         * @param {string} [priceSort] priceSort
         * @param {string} [text] text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarItemsUsingGET(page: number, pageSize: number, dateSort?: string, location?: string, model?: string, priceSort?: string, text?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCarItemsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getCarItemsUsingGET.');
            }
            const localVarPath = `/items/car`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dateSort !== undefined) {
                localVarQueryParameter['dateSort'] = dateSort;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (priceSort !== undefined) {
                localVarQueryParameter['priceSort'] = priceSort;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFlatItems
         * @param {number} page page
         * @param {string} [city] city
         * @param {boolean} [sorted] sorted
         * @param {string} [street] street
         * @param {string} [text] text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlatItemsUsingGET(page: number, city?: string, sorted?: boolean, street?: string, text?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getFlatItemsUsingGET.');
            }
            const localVarPath = `/items/flat`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sorted !== undefined) {
                localVarQueryParameter['sorted'] = sorted;
            }

            if (street !== undefined) {
                localVarQueryParameter['street'] = street;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getParkingItems
         * @param {number} page page
         * @param {number} pageSize pageSize
         * @param {boolean} [active] active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkingItemsUsingGET(page: number, pageSize: number, active?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getParkingItemsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getParkingItemsUsingGET.');
            }
            const localVarPath = `/items/parking`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsControllerApi - functional programming interface
 * @export
 */
export const ItemsControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCarItems
         * @param {number} page page
         * @param {number} pageSize pageSize
         * @param {string} [dateSort] dateSort
         * @param {string} [location] location
         * @param {string} [model] model
         * @param {string} [priceSort] priceSort
         * @param {string} [text] text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarItemsUsingGET(page: number, pageSize: number, dateSort?: string, location?: string, model?: string, priceSort?: string, text?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CarItemsResponse> {
            const localVarFetchArgs = ItemsControllerApiFetchParamCreator(configuration).getCarItemsUsingGET(page, pageSize, dateSort, location, model, priceSort, text, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getFlatItems
         * @param {number} page page
         * @param {string} [city] city
         * @param {boolean} [sorted] sorted
         * @param {string} [street] street
         * @param {string} [text] text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlatItemsUsingGET(page: number, city?: string, sorted?: boolean, street?: string, text?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FlatItemsResponse> {
            const localVarFetchArgs = ItemsControllerApiFetchParamCreator(configuration).getFlatItemsUsingGET(page, city, sorted, street, text, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getParkingItems
         * @param {number} page page
         * @param {number} pageSize pageSize
         * @param {boolean} [active] active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkingItemsUsingGET(page: number, pageSize: number, active?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParkingItemsResponse> {
            const localVarFetchArgs = ItemsControllerApiFetchParamCreator(configuration).getParkingItemsUsingGET(page, pageSize, active, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItemsControllerApi - factory interface
 * @export
 */
export const ItemsControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getCarItems
         * @param {number} page page
         * @param {number} pageSize pageSize
         * @param {string} [dateSort] dateSort
         * @param {string} [location] location
         * @param {string} [model] model
         * @param {string} [priceSort] priceSort
         * @param {string} [text] text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarItemsUsingGET(page: number, pageSize: number, dateSort?: string, location?: string, model?: string, priceSort?: string, text?: string, options?: any) {
            return ItemsControllerApiFp(configuration).getCarItemsUsingGET(page, pageSize, dateSort, location, model, priceSort, text, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getFlatItems
         * @param {number} page page
         * @param {string} [city] city
         * @param {boolean} [sorted] sorted
         * @param {string} [street] street
         * @param {string} [text] text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlatItemsUsingGET(page: number, city?: string, sorted?: boolean, street?: string, text?: string, options?: any) {
            return ItemsControllerApiFp(configuration).getFlatItemsUsingGET(page, city, sorted, street, text, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getParkingItems
         * @param {number} page page
         * @param {number} pageSize pageSize
         * @param {boolean} [active] active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkingItemsUsingGET(page: number, pageSize: number, active?: boolean, options?: any) {
            return ItemsControllerApiFp(configuration).getParkingItemsUsingGET(page, pageSize, active, options)(fetch, basePath);
        },
    };
};

/**
 * ItemsControllerApi - object-oriented interface
 * @export
 * @class ItemsControllerApi
 * @extends {BaseAPI}
 */
export class ItemsControllerApi extends BaseAPI {
    /**
     * 
     * @summary getCarItems
     * @param {number} page page
     * @param {number} pageSize pageSize
     * @param {string} [dateSort] dateSort
     * @param {string} [location] location
     * @param {string} [model] model
     * @param {string} [priceSort] priceSort
     * @param {string} [text] text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsControllerApi
     */
    public getCarItemsUsingGET(page: number, pageSize: number, dateSort?: string, location?: string, model?: string, priceSort?: string, text?: string, options?: any) {
        return ItemsControllerApiFp(this.configuration).getCarItemsUsingGET(page, pageSize, dateSort, location, model, priceSort, text, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getFlatItems
     * @param {number} page page
     * @param {string} [city] city
     * @param {boolean} [sorted] sorted
     * @param {string} [street] street
     * @param {string} [text] text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsControllerApi
     */
    public getFlatItemsUsingGET(page: number, city?: string, sorted?: boolean, street?: string, text?: string, options?: any) {
        return ItemsControllerApiFp(this.configuration).getFlatItemsUsingGET(page, city, sorted, street, text, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getParkingItems
     * @param {number} page page
     * @param {number} pageSize pageSize
     * @param {boolean} [active] active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsControllerApi
     */
    public getParkingItemsUsingGET(page: number, pageSize: number, active?: boolean, options?: any) {
        return ItemsControllerApiFp(this.configuration).getParkingItemsUsingGET(page, pageSize, active, options)(this.fetch, this.basePath);
    }

}
/**
 * JwtAuthenticationControllerApi - fetch parameter creator
 * @export
 */
export const JwtAuthenticationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createAuthenticationToken
         * @param {JwtRequest} body authenticationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthenticationTokenUsingPOST(body: JwtRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAuthenticationTokenUsingPOST.');
            }
            const localVarPath = `/authenticate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JwtRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JwtAuthenticationControllerApi - functional programming interface
 * @export
 */
export const JwtAuthenticationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createAuthenticationToken
         * @param {JwtRequest} body authenticationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthenticationTokenUsingPOST(body: JwtRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JwtAuthenticationControllerApiFetchParamCreator(configuration).createAuthenticationTokenUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JwtAuthenticationControllerApi - factory interface
 * @export
 */
export const JwtAuthenticationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createAuthenticationToken
         * @param {JwtRequest} body authenticationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthenticationTokenUsingPOST(body: JwtRequest, options?: any) {
            return JwtAuthenticationControllerApiFp(configuration).createAuthenticationTokenUsingPOST(body, options)(fetch, basePath);
        },
    };
};

/**
 * JwtAuthenticationControllerApi - object-oriented interface
 * @export
 * @class JwtAuthenticationControllerApi
 * @extends {BaseAPI}
 */
export class JwtAuthenticationControllerApi extends BaseAPI {
    /**
     * 
     * @summary createAuthenticationToken
     * @param {JwtRequest} body authenticationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JwtAuthenticationControllerApi
     */
    public createAuthenticationTokenUsingPOST(body: JwtRequest, options?: any) {
        return JwtAuthenticationControllerApiFp(this.configuration).createAuthenticationTokenUsingPOST(body, options)(this.fetch, this.basePath);
    }

}
/**
 * JwtUserControllerApi - fetch parameter creator
 * @export
 */
export const JwtUserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createUser
         * @param {User} body user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(body: User, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUserUsingPOST.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JwtUserControllerApi - functional programming interface
 * @export
 */
export const JwtUserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createUser
         * @param {User} body user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = JwtUserControllerApiFetchParamCreator(configuration).createUserUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JwtUserControllerApi - factory interface
 * @export
 */
export const JwtUserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createUser
         * @param {User} body user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(body: User, options?: any) {
            return JwtUserControllerApiFp(configuration).createUserUsingPOST(body, options)(fetch, basePath);
        },
    };
};

/**
 * JwtUserControllerApi - object-oriented interface
 * @export
 * @class JwtUserControllerApi
 * @extends {BaseAPI}
 */
export class JwtUserControllerApi extends BaseAPI {
    /**
     * 
     * @summary createUser
     * @param {User} body user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JwtUserControllerApi
     */
    public createUserUsingPOST(body: User, options?: any) {
        return JwtUserControllerApiFp(this.configuration).createUserUsingPOST(body, options)(this.fetch, this.basePath);
    }

}
/**
 * OperationHandlerApi - fetch parameter creator
 * @export
 */
export const OperationHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: { [key: string]: string; }, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/beans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: { [key: string]: string; }, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: { [key: string]: string; }, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health/**`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET3(body?: { [key: string]: string; }, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/loggers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET4(body?: { [key: string]: string; }, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/loggers/{name}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingPOST(body?: { [key: string]: string; }, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/loggers/{name}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationHandlerApi - functional programming interface
 * @export
 */
export const OperationHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: { [key: string]: string; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: { [key: string]: string; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET1(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: { [key: string]: string; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET2(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET3(body?: { [key: string]: string; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET3(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET4(body?: { [key: string]: string; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET4(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingPOST(body?: { [key: string]: string; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperationHandlerApi - factory interface
 * @export
 */
export const OperationHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: { [key: string]: string; }, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: { [key: string]: string; }, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET1(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: { [key: string]: string; }, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET2(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET3(body?: { [key: string]: string; }, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET3(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET4(body?: { [key: string]: string; }, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET4(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {{ [key: string]: string; }} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingPOST(body?: { [key: string]: string; }, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingPOST(body, options)(fetch, basePath);
        },
    };
};

/**
 * OperationHandlerApi - object-oriented interface
 * @export
 * @class OperationHandlerApi
 * @extends {BaseAPI}
 */
export class OperationHandlerApi extends BaseAPI {
    /**
     * 
     * @summary handle
     * @param {{ [key: string]: string; }} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET(body?: { [key: string]: string; }, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {{ [key: string]: string; }} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET1(body?: { [key: string]: string; }, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET1(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {{ [key: string]: string; }} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET2(body?: { [key: string]: string; }, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET2(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {{ [key: string]: string; }} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET3(body?: { [key: string]: string; }, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET3(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {{ [key: string]: string; }} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET4(body?: { [key: string]: string; }, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET4(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {{ [key: string]: string; }} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingPOST(body?: { [key: string]: string; }, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingPOST(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UsersControllerApi - fetch parameter creator
 * @export
 */
export const UsersControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary disableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUserUsingDELETE(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling disableUserUsingDELETE.');
            }
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUsers
         * @param {number} page page
         * @param {number} size size
         * @param {boolean} [active] active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET(page: number, size: number, active?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUsersUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getUsersUsingGET.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateUser
         * @param {UpdateUserDto} body updateUserDto
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsingPUT(body: UpdateUserDto, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserUsingPUT.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserUsingPUT.');
            }
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersControllerApi - functional programming interface
 * @export
 */
export const UsersControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary disableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUserUsingDELETE(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UsersControllerApiFetchParamCreator(configuration).disableUserUsingDELETE(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUsers
         * @param {number} page page
         * @param {number} size size
         * @param {boolean} [active] active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET(page: number, size: number, active?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsersResponse> {
            const localVarFetchArgs = UsersControllerApiFetchParamCreator(configuration).getUsersUsingGET(page, size, active, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateUser
         * @param {UpdateUserDto} body updateUserDto
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsingPUT(body: UpdateUserDto, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersControllerApiFetchParamCreator(configuration).updateUserUsingPUT(body, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersControllerApi - factory interface
 * @export
 */
export const UsersControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary disableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUserUsingDELETE(userId: number, options?: any) {
            return UsersControllerApiFp(configuration).disableUserUsingDELETE(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUsers
         * @param {number} page page
         * @param {number} size size
         * @param {boolean} [active] active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET(page: number, size: number, active?: boolean, options?: any) {
            return UsersControllerApiFp(configuration).getUsersUsingGET(page, size, active, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateUser
         * @param {UpdateUserDto} body updateUserDto
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsingPUT(body: UpdateUserDto, userId: number, options?: any) {
            return UsersControllerApiFp(configuration).updateUserUsingPUT(body, userId, options)(fetch, basePath);
        },
    };
};

/**
 * UsersControllerApi - object-oriented interface
 * @export
 * @class UsersControllerApi
 * @extends {BaseAPI}
 */
export class UsersControllerApi extends BaseAPI {
    /**
     * 
     * @summary disableUser
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public disableUserUsingDELETE(userId: number, options?: any) {
        return UsersControllerApiFp(this.configuration).disableUserUsingDELETE(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUsers
     * @param {number} page page
     * @param {number} size size
     * @param {boolean} [active] active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getUsersUsingGET(page: number, size: number, active?: boolean, options?: any) {
        return UsersControllerApiFp(this.configuration).getUsersUsingGET(page, size, active, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateUser
     * @param {UpdateUserDto} body updateUserDto
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public updateUserUsingPUT(body: UpdateUserDto, userId: number, options?: any) {
        return UsersControllerApiFp(this.configuration).updateUserUsingPUT(body, userId, options)(this.fetch, this.basePath);
    }

}
/**
 * WebMvcLinksHandlerApi - fetch parameter creator
 * @export
 */
export const WebMvcLinksHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/actuator`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - functional programming interface
 * @export
 */
export const WebMvcLinksHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: { [key: string]: Link; }; }> {
            const localVarFetchArgs = WebMvcLinksHandlerApiFetchParamCreator(configuration).linksUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - factory interface
 * @export
 */
export const WebMvcLinksHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any) {
            return WebMvcLinksHandlerApiFp(configuration).linksUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * WebMvcLinksHandlerApi - object-oriented interface
 * @export
 * @class WebMvcLinksHandlerApi
 * @extends {BaseAPI}
 */
export class WebMvcLinksHandlerApi extends BaseAPI {
    /**
     * 
     * @summary links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebMvcLinksHandlerApi
     */
    public linksUsingGET(options?: any) {
        return WebMvcLinksHandlerApiFp(this.configuration).linksUsingGET(options)(this.fetch, this.basePath);
    }

}
